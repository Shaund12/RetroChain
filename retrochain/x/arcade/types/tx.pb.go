// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: retrochain/arcade/v1/tx.proto

package types

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgUpdateParams is the Msg/UpdateParams request type.
type MsgUpdateParams struct {
	// authority is the address that controls the module (defaults to x/gov unless overwritten).
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	// NOTE: All parameters must be supplied.
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{0}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateParams) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

// MsgUpdateParamsResponse defines the response structure for executing a
// MsgUpdateParams message.
type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{1}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

// MsgInsertCoin defines the MsgInsertCoin message.
type MsgInsertCoin struct {
	Creator string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Credits uint64 `protobuf:"varint,2,opt,name=credits,proto3" json:"credits,omitempty"`
	GameId  string `protobuf:"bytes,3,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
}

func (m *MsgInsertCoin) Reset()         { *m = MsgInsertCoin{} }
func (m *MsgInsertCoin) String() string { return proto.CompactTextString(m) }
func (*MsgInsertCoin) ProtoMessage()    {}
func (*MsgInsertCoin) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{2}
}
func (m *MsgInsertCoin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInsertCoin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInsertCoin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInsertCoin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInsertCoin.Merge(m, src)
}
func (m *MsgInsertCoin) XXX_Size() int {
	return m.Size()
}
func (m *MsgInsertCoin) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInsertCoin.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInsertCoin proto.InternalMessageInfo

func (m *MsgInsertCoin) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgInsertCoin) GetCredits() uint64 {
	if m != nil {
		return m.Credits
	}
	return 0
}

func (m *MsgInsertCoin) GetGameId() string {
	if m != nil {
		return m.GameId
	}
	return ""
}

// MsgInsertCoinResponse defines the MsgInsertCoinResponse message.
type MsgInsertCoinResponse struct {
	TotalCredits uint64 `protobuf:"varint,1,opt,name=total_credits,json=totalCredits,proto3" json:"total_credits,omitempty"`
	TokensSpent  string `protobuf:"bytes,2,opt,name=tokens_spent,json=tokensSpent,proto3" json:"tokens_spent,omitempty"`
}

func (m *MsgInsertCoinResponse) Reset()         { *m = MsgInsertCoinResponse{} }
func (m *MsgInsertCoinResponse) String() string { return proto.CompactTextString(m) }
func (*MsgInsertCoinResponse) ProtoMessage()    {}
func (*MsgInsertCoinResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{3}
}
func (m *MsgInsertCoinResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgInsertCoinResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgInsertCoinResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgInsertCoinResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgInsertCoinResponse.Merge(m, src)
}
func (m *MsgInsertCoinResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgInsertCoinResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgInsertCoinResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgInsertCoinResponse proto.InternalMessageInfo

func (m *MsgInsertCoinResponse) GetTotalCredits() uint64 {
	if m != nil {
		return m.TotalCredits
	}
	return 0
}

func (m *MsgInsertCoinResponse) GetTokensSpent() string {
	if m != nil {
		return m.TokensSpent
	}
	return ""
}

// MsgStartSession defines the MsgStartSession message.
type MsgStartSession struct {
	Creator    string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	GameId     string `protobuf:"bytes,2,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	Difficulty uint64 `protobuf:"varint,3,opt,name=difficulty,proto3" json:"difficulty,omitempty"`
}

func (m *MsgStartSession) Reset()         { *m = MsgStartSession{} }
func (m *MsgStartSession) String() string { return proto.CompactTextString(m) }
func (*MsgStartSession) ProtoMessage()    {}
func (*MsgStartSession) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{4}
}
func (m *MsgStartSession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgStartSession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgStartSession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgStartSession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgStartSession.Merge(m, src)
}
func (m *MsgStartSession) XXX_Size() int {
	return m.Size()
}
func (m *MsgStartSession) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgStartSession.DiscardUnknown(m)
}

var xxx_messageInfo_MsgStartSession proto.InternalMessageInfo

func (m *MsgStartSession) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgStartSession) GetGameId() string {
	if m != nil {
		return m.GameId
	}
	return ""
}

func (m *MsgStartSession) GetDifficulty() uint64 {
	if m != nil {
		return m.Difficulty
	}
	return 0
}

// MsgStartSessionResponse defines the MsgStartSessionResponse message.
type MsgStartSessionResponse struct {
	SessionId     uint64 `protobuf:"varint,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	StartingLives uint64 `protobuf:"varint,2,opt,name=starting_lives,json=startingLives,proto3" json:"starting_lives,omitempty"`
	StartingLevel uint64 `protobuf:"varint,3,opt,name=starting_level,json=startingLevel,proto3" json:"starting_level,omitempty"`
}

func (m *MsgStartSessionResponse) Reset()         { *m = MsgStartSessionResponse{} }
func (m *MsgStartSessionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgStartSessionResponse) ProtoMessage()    {}
func (*MsgStartSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{5}
}
func (m *MsgStartSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgStartSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgStartSessionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgStartSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgStartSessionResponse.Merge(m, src)
}
func (m *MsgStartSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgStartSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgStartSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgStartSessionResponse proto.InternalMessageInfo

func (m *MsgStartSessionResponse) GetSessionId() uint64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *MsgStartSessionResponse) GetStartingLives() uint64 {
	if m != nil {
		return m.StartingLives
	}
	return 0
}

func (m *MsgStartSessionResponse) GetStartingLevel() uint64 {
	if m != nil {
		return m.StartingLevel
	}
	return 0
}

// MsgSubmitScore defines the MsgSubmitScore message.
type MsgSubmitScore struct {
	Creator   string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	SessionId uint64 `protobuf:"varint,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	Score     uint64 `protobuf:"varint,3,opt,name=score,proto3" json:"score,omitempty"`
	Level     uint64 `protobuf:"varint,4,opt,name=level,proto3" json:"level,omitempty"`
	GameOver  bool   `protobuf:"varint,5,opt,name=game_over,json=gameOver,proto3" json:"game_over,omitempty"`
}

func (m *MsgSubmitScore) Reset()         { *m = MsgSubmitScore{} }
func (m *MsgSubmitScore) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitScore) ProtoMessage()    {}
func (*MsgSubmitScore) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{6}
}
func (m *MsgSubmitScore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitScore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitScore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitScore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitScore.Merge(m, src)
}
func (m *MsgSubmitScore) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitScore) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitScore.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitScore proto.InternalMessageInfo

func (m *MsgSubmitScore) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSubmitScore) GetSessionId() uint64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *MsgSubmitScore) GetScore() uint64 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *MsgSubmitScore) GetLevel() uint64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *MsgSubmitScore) GetGameOver() bool {
	if m != nil {
		return m.GameOver
	}
	return false
}

// MsgSubmitScoreResponse defines the MsgSubmitScoreResponse message.
type MsgSubmitScoreResponse struct {
	IsHighScore          bool     `protobuf:"varint,1,opt,name=is_high_score,json=isHighScore,proto3" json:"is_high_score,omitempty"`
	Rank                 uint64   `protobuf:"varint,2,opt,name=rank,proto3" json:"rank,omitempty"`
	TokensEarned         uint64   `protobuf:"varint,3,opt,name=tokens_earned,json=tokensEarned,proto3" json:"tokens_earned,omitempty"`
	AchievementsUnlocked []string `protobuf:"bytes,4,rep,name=achievements_unlocked,json=achievementsUnlocked,proto3" json:"achievements_unlocked,omitempty"`
}

func (m *MsgSubmitScoreResponse) Reset()         { *m = MsgSubmitScoreResponse{} }
func (m *MsgSubmitScoreResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitScoreResponse) ProtoMessage()    {}
func (*MsgSubmitScoreResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{7}
}
func (m *MsgSubmitScoreResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitScoreResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitScoreResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitScoreResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitScoreResponse.Merge(m, src)
}
func (m *MsgSubmitScoreResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitScoreResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitScoreResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitScoreResponse proto.InternalMessageInfo

func (m *MsgSubmitScoreResponse) GetIsHighScore() bool {
	if m != nil {
		return m.IsHighScore
	}
	return false
}

func (m *MsgSubmitScoreResponse) GetRank() uint64 {
	if m != nil {
		return m.Rank
	}
	return 0
}

func (m *MsgSubmitScoreResponse) GetTokensEarned() uint64 {
	if m != nil {
		return m.TokensEarned
	}
	return 0
}

func (m *MsgSubmitScoreResponse) GetAchievementsUnlocked() []string {
	if m != nil {
		return m.AchievementsUnlocked
	}
	return nil
}

// MsgEndSession defines the MsgEndSession message.
type MsgEndSession struct {
	Creator    string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	SessionId  uint64 `protobuf:"varint,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	FinalScore uint64 `protobuf:"varint,3,opt,name=final_score,json=finalScore,proto3" json:"final_score,omitempty"`
	FinalLevel uint64 `protobuf:"varint,4,opt,name=final_level,json=finalLevel,proto3" json:"final_level,omitempty"`
}

func (m *MsgEndSession) Reset()         { *m = MsgEndSession{} }
func (m *MsgEndSession) String() string { return proto.CompactTextString(m) }
func (*MsgEndSession) ProtoMessage()    {}
func (*MsgEndSession) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{8}
}
func (m *MsgEndSession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEndSession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEndSession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEndSession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEndSession.Merge(m, src)
}
func (m *MsgEndSession) XXX_Size() int {
	return m.Size()
}
func (m *MsgEndSession) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEndSession.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEndSession proto.InternalMessageInfo

func (m *MsgEndSession) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgEndSession) GetSessionId() uint64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *MsgEndSession) GetFinalScore() uint64 {
	if m != nil {
		return m.FinalScore
	}
	return 0
}

func (m *MsgEndSession) GetFinalLevel() uint64 {
	if m != nil {
		return m.FinalLevel
	}
	return 0
}

// MsgEndSessionResponse defines the MsgEndSessionResponse message.
type MsgEndSessionResponse struct {
	SessionEnded bool   `protobuf:"varint,1,opt,name=session_ended,json=sessionEnded,proto3" json:"session_ended,omitempty"`
	Summary      string `protobuf:"bytes,2,opt,name=summary,proto3" json:"summary,omitempty"`
}

func (m *MsgEndSessionResponse) Reset()         { *m = MsgEndSessionResponse{} }
func (m *MsgEndSessionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgEndSessionResponse) ProtoMessage()    {}
func (*MsgEndSessionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{9}
}
func (m *MsgEndSessionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEndSessionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEndSessionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEndSessionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEndSessionResponse.Merge(m, src)
}
func (m *MsgEndSessionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgEndSessionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEndSessionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEndSessionResponse proto.InternalMessageInfo

func (m *MsgEndSessionResponse) GetSessionEnded() bool {
	if m != nil {
		return m.SessionEnded
	}
	return false
}

func (m *MsgEndSessionResponse) GetSummary() string {
	if m != nil {
		return m.Summary
	}
	return ""
}

// MsgRegisterGame defines the MsgRegisterGame message.
type MsgRegisterGame struct {
	Creator string     `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Game    ArcadeGame `protobuf:"bytes,2,opt,name=game,proto3" json:"game"`
}

func (m *MsgRegisterGame) Reset()         { *m = MsgRegisterGame{} }
func (m *MsgRegisterGame) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterGame) ProtoMessage()    {}
func (*MsgRegisterGame) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{10}
}
func (m *MsgRegisterGame) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterGame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterGame.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterGame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterGame.Merge(m, src)
}
func (m *MsgRegisterGame) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterGame) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterGame.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterGame proto.InternalMessageInfo

func (m *MsgRegisterGame) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgRegisterGame) GetGame() ArcadeGame {
	if m != nil {
		return m.Game
	}
	return ArcadeGame{}
}

// MsgRegisterGameResponse defines the MsgRegisterGameResponse message.
type MsgRegisterGameResponse struct {
	GameId string `protobuf:"bytes,1,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
}

func (m *MsgRegisterGameResponse) Reset()         { *m = MsgRegisterGameResponse{} }
func (m *MsgRegisterGameResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterGameResponse) ProtoMessage()    {}
func (*MsgRegisterGameResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{11}
}
func (m *MsgRegisterGameResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterGameResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterGameResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterGameResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterGameResponse.Merge(m, src)
}
func (m *MsgRegisterGameResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterGameResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterGameResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterGameResponse proto.InternalMessageInfo

func (m *MsgRegisterGameResponse) GetGameId() string {
	if m != nil {
		return m.GameId
	}
	return ""
}

// MsgUpdateGameScore defines the MsgUpdateGameScore message.
type MsgUpdateGameScore struct {
	Creator      string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	SessionId    uint64 `protobuf:"varint,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	ScoreDelta   uint64 `protobuf:"varint,3,opt,name=score_delta,json=scoreDelta,proto3" json:"score_delta,omitempty"`
	CurrentLevel uint64 `protobuf:"varint,4,opt,name=current_level,json=currentLevel,proto3" json:"current_level,omitempty"`
	CurrentLives uint64 `protobuf:"varint,5,opt,name=current_lives,json=currentLives,proto3" json:"current_lives,omitempty"`
}

func (m *MsgUpdateGameScore) Reset()         { *m = MsgUpdateGameScore{} }
func (m *MsgUpdateGameScore) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateGameScore) ProtoMessage()    {}
func (*MsgUpdateGameScore) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{12}
}
func (m *MsgUpdateGameScore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateGameScore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateGameScore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateGameScore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateGameScore.Merge(m, src)
}
func (m *MsgUpdateGameScore) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateGameScore) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateGameScore.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateGameScore proto.InternalMessageInfo

func (m *MsgUpdateGameScore) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgUpdateGameScore) GetSessionId() uint64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *MsgUpdateGameScore) GetScoreDelta() uint64 {
	if m != nil {
		return m.ScoreDelta
	}
	return 0
}

func (m *MsgUpdateGameScore) GetCurrentLevel() uint64 {
	if m != nil {
		return m.CurrentLevel
	}
	return 0
}

func (m *MsgUpdateGameScore) GetCurrentLives() uint64 {
	if m != nil {
		return m.CurrentLives
	}
	return 0
}

// MsgUpdateGameScoreResponse defines the MsgUpdateGameScoreResponse message.
type MsgUpdateGameScoreResponse struct {
	TotalScore uint64 `protobuf:"varint,1,opt,name=total_score,json=totalScore,proto3" json:"total_score,omitempty"`
}

func (m *MsgUpdateGameScoreResponse) Reset()         { *m = MsgUpdateGameScoreResponse{} }
func (m *MsgUpdateGameScoreResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateGameScoreResponse) ProtoMessage()    {}
func (*MsgUpdateGameScoreResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{13}
}
func (m *MsgUpdateGameScoreResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateGameScoreResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateGameScoreResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateGameScoreResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateGameScoreResponse.Merge(m, src)
}
func (m *MsgUpdateGameScoreResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateGameScoreResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateGameScoreResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateGameScoreResponse proto.InternalMessageInfo

func (m *MsgUpdateGameScoreResponse) GetTotalScore() uint64 {
	if m != nil {
		return m.TotalScore
	}
	return 0
}

// MsgActivateCombo defines the MsgActivateCombo message.
type MsgActivateCombo struct {
	Creator   string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	SessionId uint64 `protobuf:"varint,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	ComboHits uint64 `protobuf:"varint,3,opt,name=combo_hits,json=comboHits,proto3" json:"combo_hits,omitempty"`
}

func (m *MsgActivateCombo) Reset()         { *m = MsgActivateCombo{} }
func (m *MsgActivateCombo) String() string { return proto.CompactTextString(m) }
func (*MsgActivateCombo) ProtoMessage()    {}
func (*MsgActivateCombo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{14}
}
func (m *MsgActivateCombo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgActivateCombo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgActivateCombo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgActivateCombo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgActivateCombo.Merge(m, src)
}
func (m *MsgActivateCombo) XXX_Size() int {
	return m.Size()
}
func (m *MsgActivateCombo) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgActivateCombo.DiscardUnknown(m)
}

var xxx_messageInfo_MsgActivateCombo proto.InternalMessageInfo

func (m *MsgActivateCombo) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgActivateCombo) GetSessionId() uint64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *MsgActivateCombo) GetComboHits() uint64 {
	if m != nil {
		return m.ComboHits
	}
	return 0
}

// MsgActivateComboResponse defines the MsgActivateComboResponse message.
type MsgActivateComboResponse struct {
	Multiplier uint64 `protobuf:"varint,1,opt,name=multiplier,proto3" json:"multiplier,omitempty"`
	BonusScore uint64 `protobuf:"varint,2,opt,name=bonus_score,json=bonusScore,proto3" json:"bonus_score,omitempty"`
}

func (m *MsgActivateComboResponse) Reset()         { *m = MsgActivateComboResponse{} }
func (m *MsgActivateComboResponse) String() string { return proto.CompactTextString(m) }
func (*MsgActivateComboResponse) ProtoMessage()    {}
func (*MsgActivateComboResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{15}
}
func (m *MsgActivateComboResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgActivateComboResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgActivateComboResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgActivateComboResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgActivateComboResponse.Merge(m, src)
}
func (m *MsgActivateComboResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgActivateComboResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgActivateComboResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgActivateComboResponse proto.InternalMessageInfo

func (m *MsgActivateComboResponse) GetMultiplier() uint64 {
	if m != nil {
		return m.Multiplier
	}
	return 0
}

func (m *MsgActivateComboResponse) GetBonusScore() uint64 {
	if m != nil {
		return m.BonusScore
	}
	return 0
}

// MsgUsePowerUp defines the MsgUsePowerUp message.
type MsgUsePowerUp struct {
	Creator   string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	SessionId uint64 `protobuf:"varint,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
	PowerUpId string `protobuf:"bytes,3,opt,name=power_up_id,json=powerUpId,proto3" json:"power_up_id,omitempty"`
}

func (m *MsgUsePowerUp) Reset()         { *m = MsgUsePowerUp{} }
func (m *MsgUsePowerUp) String() string { return proto.CompactTextString(m) }
func (*MsgUsePowerUp) ProtoMessage()    {}
func (*MsgUsePowerUp) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{16}
}
func (m *MsgUsePowerUp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUsePowerUp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUsePowerUp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUsePowerUp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUsePowerUp.Merge(m, src)
}
func (m *MsgUsePowerUp) XXX_Size() int {
	return m.Size()
}
func (m *MsgUsePowerUp) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUsePowerUp.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUsePowerUp proto.InternalMessageInfo

func (m *MsgUsePowerUp) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgUsePowerUp) GetSessionId() uint64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

func (m *MsgUsePowerUp) GetPowerUpId() string {
	if m != nil {
		return m.PowerUpId
	}
	return ""
}

// MsgUsePowerUpResponse defines the MsgUsePowerUpResponse message.
type MsgUsePowerUpResponse struct {
	Activated bool   `protobuf:"varint,1,opt,name=activated,proto3" json:"activated,omitempty"`
	Effect    string `protobuf:"bytes,2,opt,name=effect,proto3" json:"effect,omitempty"`
}

func (m *MsgUsePowerUpResponse) Reset()         { *m = MsgUsePowerUpResponse{} }
func (m *MsgUsePowerUpResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUsePowerUpResponse) ProtoMessage()    {}
func (*MsgUsePowerUpResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{17}
}
func (m *MsgUsePowerUpResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUsePowerUpResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUsePowerUpResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUsePowerUpResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUsePowerUpResponse.Merge(m, src)
}
func (m *MsgUsePowerUpResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUsePowerUpResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUsePowerUpResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUsePowerUpResponse proto.InternalMessageInfo

func (m *MsgUsePowerUpResponse) GetActivated() bool {
	if m != nil {
		return m.Activated
	}
	return false
}

func (m *MsgUsePowerUpResponse) GetEffect() string {
	if m != nil {
		return m.Effect
	}
	return ""
}

// MsgContinueGame defines the MsgContinueGame message.
type MsgContinueGame struct {
	Creator   string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	SessionId uint64 `protobuf:"varint,2,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
}

func (m *MsgContinueGame) Reset()         { *m = MsgContinueGame{} }
func (m *MsgContinueGame) String() string { return proto.CompactTextString(m) }
func (*MsgContinueGame) ProtoMessage()    {}
func (*MsgContinueGame) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{18}
}
func (m *MsgContinueGame) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgContinueGame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgContinueGame.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgContinueGame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgContinueGame.Merge(m, src)
}
func (m *MsgContinueGame) XXX_Size() int {
	return m.Size()
}
func (m *MsgContinueGame) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgContinueGame.DiscardUnknown(m)
}

var xxx_messageInfo_MsgContinueGame proto.InternalMessageInfo

func (m *MsgContinueGame) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgContinueGame) GetSessionId() uint64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

// MsgContinueGameResponse defines the MsgContinueGameResponse message.
type MsgContinueGameResponse struct {
	ContinuesRemaining uint64 `protobuf:"varint,1,opt,name=continues_remaining,json=continuesRemaining,proto3" json:"continues_remaining,omitempty"`
	LivesGranted       uint64 `protobuf:"varint,2,opt,name=lives_granted,json=livesGranted,proto3" json:"lives_granted,omitempty"`
	Cost               string `protobuf:"bytes,3,opt,name=cost,proto3" json:"cost,omitempty"`
}

func (m *MsgContinueGameResponse) Reset()         { *m = MsgContinueGameResponse{} }
func (m *MsgContinueGameResponse) String() string { return proto.CompactTextString(m) }
func (*MsgContinueGameResponse) ProtoMessage()    {}
func (*MsgContinueGameResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{19}
}
func (m *MsgContinueGameResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgContinueGameResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgContinueGameResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgContinueGameResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgContinueGameResponse.Merge(m, src)
}
func (m *MsgContinueGameResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgContinueGameResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgContinueGameResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgContinueGameResponse proto.InternalMessageInfo

func (m *MsgContinueGameResponse) GetContinuesRemaining() uint64 {
	if m != nil {
		return m.ContinuesRemaining
	}
	return 0
}

func (m *MsgContinueGameResponse) GetLivesGranted() uint64 {
	if m != nil {
		return m.LivesGranted
	}
	return 0
}

func (m *MsgContinueGameResponse) GetCost() string {
	if m != nil {
		return m.Cost
	}
	return ""
}

// MsgClaimAchievement defines the MsgClaimAchievement message.
type MsgClaimAchievement struct {
	Creator       string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	AchievementId string `protobuf:"bytes,2,opt,name=achievement_id,json=achievementId,proto3" json:"achievement_id,omitempty"`
	GameId        string `protobuf:"bytes,3,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
}

func (m *MsgClaimAchievement) Reset()         { *m = MsgClaimAchievement{} }
func (m *MsgClaimAchievement) String() string { return proto.CompactTextString(m) }
func (*MsgClaimAchievement) ProtoMessage()    {}
func (*MsgClaimAchievement) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{20}
}
func (m *MsgClaimAchievement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimAchievement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimAchievement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimAchievement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimAchievement.Merge(m, src)
}
func (m *MsgClaimAchievement) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimAchievement) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimAchievement.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimAchievement proto.InternalMessageInfo

func (m *MsgClaimAchievement) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgClaimAchievement) GetAchievementId() string {
	if m != nil {
		return m.AchievementId
	}
	return ""
}

func (m *MsgClaimAchievement) GetGameId() string {
	if m != nil {
		return m.GameId
	}
	return ""
}

// MsgClaimAchievementResponse defines the MsgClaimAchievementResponse message.
type MsgClaimAchievementResponse struct {
	TokensAwarded   uint64 `protobuf:"varint,1,opt,name=tokens_awarded,json=tokensAwarded,proto3" json:"tokens_awarded,omitempty"`
	AchievementName string `protobuf:"bytes,2,opt,name=achievement_name,json=achievementName,proto3" json:"achievement_name,omitempty"`
}

func (m *MsgClaimAchievementResponse) Reset()         { *m = MsgClaimAchievementResponse{} }
func (m *MsgClaimAchievementResponse) String() string { return proto.CompactTextString(m) }
func (*MsgClaimAchievementResponse) ProtoMessage()    {}
func (*MsgClaimAchievementResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{21}
}
func (m *MsgClaimAchievementResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimAchievementResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimAchievementResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimAchievementResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimAchievementResponse.Merge(m, src)
}
func (m *MsgClaimAchievementResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimAchievementResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimAchievementResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimAchievementResponse proto.InternalMessageInfo

func (m *MsgClaimAchievementResponse) GetTokensAwarded() uint64 {
	if m != nil {
		return m.TokensAwarded
	}
	return 0
}

func (m *MsgClaimAchievementResponse) GetAchievementName() string {
	if m != nil {
		return m.AchievementName
	}
	return ""
}

// MsgCreateTournament defines the MsgCreateTournament message.
type MsgCreateTournament struct {
	Creator    string     `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	Tournament Tournament `protobuf:"bytes,2,opt,name=tournament,proto3" json:"tournament"`
}

func (m *MsgCreateTournament) Reset()         { *m = MsgCreateTournament{} }
func (m *MsgCreateTournament) String() string { return proto.CompactTextString(m) }
func (*MsgCreateTournament) ProtoMessage()    {}
func (*MsgCreateTournament) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{22}
}
func (m *MsgCreateTournament) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateTournament) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateTournament.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateTournament) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateTournament.Merge(m, src)
}
func (m *MsgCreateTournament) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateTournament) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateTournament.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateTournament proto.InternalMessageInfo

func (m *MsgCreateTournament) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgCreateTournament) GetTournament() Tournament {
	if m != nil {
		return m.Tournament
	}
	return Tournament{}
}

// MsgCreateTournamentResponse defines the MsgCreateTournamentResponse message.
type MsgCreateTournamentResponse struct {
	TournamentId string `protobuf:"bytes,1,opt,name=tournament_id,json=tournamentId,proto3" json:"tournament_id,omitempty"`
}

func (m *MsgCreateTournamentResponse) Reset()         { *m = MsgCreateTournamentResponse{} }
func (m *MsgCreateTournamentResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateTournamentResponse) ProtoMessage()    {}
func (*MsgCreateTournamentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{23}
}
func (m *MsgCreateTournamentResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateTournamentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateTournamentResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateTournamentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateTournamentResponse.Merge(m, src)
}
func (m *MsgCreateTournamentResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateTournamentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateTournamentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateTournamentResponse proto.InternalMessageInfo

func (m *MsgCreateTournamentResponse) GetTournamentId() string {
	if m != nil {
		return m.TournamentId
	}
	return ""
}

// MsgJoinTournament defines the MsgJoinTournament message.
type MsgJoinTournament struct {
	Creator      string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	TournamentId string `protobuf:"bytes,2,opt,name=tournament_id,json=tournamentId,proto3" json:"tournament_id,omitempty"`
}

func (m *MsgJoinTournament) Reset()         { *m = MsgJoinTournament{} }
func (m *MsgJoinTournament) String() string { return proto.CompactTextString(m) }
func (*MsgJoinTournament) ProtoMessage()    {}
func (*MsgJoinTournament) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{24}
}
func (m *MsgJoinTournament) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgJoinTournament) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgJoinTournament.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgJoinTournament) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgJoinTournament.Merge(m, src)
}
func (m *MsgJoinTournament) XXX_Size() int {
	return m.Size()
}
func (m *MsgJoinTournament) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgJoinTournament.DiscardUnknown(m)
}

var xxx_messageInfo_MsgJoinTournament proto.InternalMessageInfo

func (m *MsgJoinTournament) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgJoinTournament) GetTournamentId() string {
	if m != nil {
		return m.TournamentId
	}
	return ""
}

// MsgJoinTournamentResponse defines the MsgJoinTournamentResponse message.
type MsgJoinTournamentResponse struct {
	Joined           bool   `protobuf:"varint,1,opt,name=joined,proto3" json:"joined,omitempty"`
	ParticipantCount uint64 `protobuf:"varint,2,opt,name=participant_count,json=participantCount,proto3" json:"participant_count,omitempty"`
}

func (m *MsgJoinTournamentResponse) Reset()         { *m = MsgJoinTournamentResponse{} }
func (m *MsgJoinTournamentResponse) String() string { return proto.CompactTextString(m) }
func (*MsgJoinTournamentResponse) ProtoMessage()    {}
func (*MsgJoinTournamentResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{25}
}
func (m *MsgJoinTournamentResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgJoinTournamentResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgJoinTournamentResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgJoinTournamentResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgJoinTournamentResponse.Merge(m, src)
}
func (m *MsgJoinTournamentResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgJoinTournamentResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgJoinTournamentResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgJoinTournamentResponse proto.InternalMessageInfo

func (m *MsgJoinTournamentResponse) GetJoined() bool {
	if m != nil {
		return m.Joined
	}
	return false
}

func (m *MsgJoinTournamentResponse) GetParticipantCount() uint64 {
	if m != nil {
		return m.ParticipantCount
	}
	return 0
}

// MsgSubmitTournamentScore defines the MsgSubmitTournamentScore message.
type MsgSubmitTournamentScore struct {
	Creator      string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	TournamentId string `protobuf:"bytes,2,opt,name=tournament_id,json=tournamentId,proto3" json:"tournament_id,omitempty"`
	Score        uint64 `protobuf:"varint,3,opt,name=score,proto3" json:"score,omitempty"`
}

func (m *MsgSubmitTournamentScore) Reset()         { *m = MsgSubmitTournamentScore{} }
func (m *MsgSubmitTournamentScore) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitTournamentScore) ProtoMessage()    {}
func (*MsgSubmitTournamentScore) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{26}
}
func (m *MsgSubmitTournamentScore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitTournamentScore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitTournamentScore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitTournamentScore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitTournamentScore.Merge(m, src)
}
func (m *MsgSubmitTournamentScore) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitTournamentScore) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitTournamentScore.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitTournamentScore proto.InternalMessageInfo

func (m *MsgSubmitTournamentScore) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSubmitTournamentScore) GetTournamentId() string {
	if m != nil {
		return m.TournamentId
	}
	return ""
}

func (m *MsgSubmitTournamentScore) GetScore() uint64 {
	if m != nil {
		return m.Score
	}
	return 0
}

// MsgSubmitTournamentScoreResponse defines the MsgSubmitTournamentScoreResponse message.
type MsgSubmitTournamentScoreResponse struct {
	CurrentRank uint64 `protobuf:"varint,1,opt,name=current_rank,json=currentRank,proto3" json:"current_rank,omitempty"`
	Qualified   bool   `protobuf:"varint,2,opt,name=qualified,proto3" json:"qualified,omitempty"`
}

func (m *MsgSubmitTournamentScoreResponse) Reset()         { *m = MsgSubmitTournamentScoreResponse{} }
func (m *MsgSubmitTournamentScoreResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitTournamentScoreResponse) ProtoMessage()    {}
func (*MsgSubmitTournamentScoreResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{27}
}
func (m *MsgSubmitTournamentScoreResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitTournamentScoreResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitTournamentScoreResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitTournamentScoreResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitTournamentScoreResponse.Merge(m, src)
}
func (m *MsgSubmitTournamentScoreResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitTournamentScoreResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitTournamentScoreResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitTournamentScoreResponse proto.InternalMessageInfo

func (m *MsgSubmitTournamentScoreResponse) GetCurrentRank() uint64 {
	if m != nil {
		return m.CurrentRank
	}
	return 0
}

func (m *MsgSubmitTournamentScoreResponse) GetQualified() bool {
	if m != nil {
		return m.Qualified
	}
	return false
}

// MsgSetHighScoreInitials defines the MsgSetHighScoreInitials message.
type MsgSetHighScoreInitials struct {
	Creator  string `protobuf:"bytes,1,opt,name=creator,proto3" json:"creator,omitempty"`
	GameId   string `protobuf:"bytes,2,opt,name=game_id,json=gameId,proto3" json:"game_id,omitempty"`
	Initials string `protobuf:"bytes,3,opt,name=initials,proto3" json:"initials,omitempty"`
}

func (m *MsgSetHighScoreInitials) Reset()         { *m = MsgSetHighScoreInitials{} }
func (m *MsgSetHighScoreInitials) String() string { return proto.CompactTextString(m) }
func (*MsgSetHighScoreInitials) ProtoMessage()    {}
func (*MsgSetHighScoreInitials) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{28}
}
func (m *MsgSetHighScoreInitials) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetHighScoreInitials) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetHighScoreInitials.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetHighScoreInitials) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetHighScoreInitials.Merge(m, src)
}
func (m *MsgSetHighScoreInitials) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetHighScoreInitials) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetHighScoreInitials.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetHighScoreInitials proto.InternalMessageInfo

func (m *MsgSetHighScoreInitials) GetCreator() string {
	if m != nil {
		return m.Creator
	}
	return ""
}

func (m *MsgSetHighScoreInitials) GetGameId() string {
	if m != nil {
		return m.GameId
	}
	return ""
}

func (m *MsgSetHighScoreInitials) GetInitials() string {
	if m != nil {
		return m.Initials
	}
	return ""
}

// MsgSetHighScoreInitialsResponse defines the MsgSetHighScoreInitialsResponse message.
type MsgSetHighScoreInitialsResponse struct {
	Updated bool `protobuf:"varint,1,opt,name=updated,proto3" json:"updated,omitempty"`
}

func (m *MsgSetHighScoreInitialsResponse) Reset()         { *m = MsgSetHighScoreInitialsResponse{} }
func (m *MsgSetHighScoreInitialsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSetHighScoreInitialsResponse) ProtoMessage()    {}
func (*MsgSetHighScoreInitialsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d2b4261a8f20d0a7, []int{29}
}
func (m *MsgSetHighScoreInitialsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSetHighScoreInitialsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSetHighScoreInitialsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSetHighScoreInitialsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSetHighScoreInitialsResponse.Merge(m, src)
}
func (m *MsgSetHighScoreInitialsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSetHighScoreInitialsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSetHighScoreInitialsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSetHighScoreInitialsResponse proto.InternalMessageInfo

func (m *MsgSetHighScoreInitialsResponse) GetUpdated() bool {
	if m != nil {
		return m.Updated
	}
	return false
}

func init() {
	proto.RegisterType((*MsgUpdateParams)(nil), "retrochain.arcade.v1.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "retrochain.arcade.v1.MsgUpdateParamsResponse")
	proto.RegisterType((*MsgInsertCoin)(nil), "retrochain.arcade.v1.MsgInsertCoin")
	proto.RegisterType((*MsgInsertCoinResponse)(nil), "retrochain.arcade.v1.MsgInsertCoinResponse")
	proto.RegisterType((*MsgStartSession)(nil), "retrochain.arcade.v1.MsgStartSession")
	proto.RegisterType((*MsgStartSessionResponse)(nil), "retrochain.arcade.v1.MsgStartSessionResponse")
	proto.RegisterType((*MsgSubmitScore)(nil), "retrochain.arcade.v1.MsgSubmitScore")
	proto.RegisterType((*MsgSubmitScoreResponse)(nil), "retrochain.arcade.v1.MsgSubmitScoreResponse")
	proto.RegisterType((*MsgEndSession)(nil), "retrochain.arcade.v1.MsgEndSession")
	proto.RegisterType((*MsgEndSessionResponse)(nil), "retrochain.arcade.v1.MsgEndSessionResponse")
	proto.RegisterType((*MsgRegisterGame)(nil), "retrochain.arcade.v1.MsgRegisterGame")
	proto.RegisterType((*MsgRegisterGameResponse)(nil), "retrochain.arcade.v1.MsgRegisterGameResponse")
	proto.RegisterType((*MsgUpdateGameScore)(nil), "retrochain.arcade.v1.MsgUpdateGameScore")
	proto.RegisterType((*MsgUpdateGameScoreResponse)(nil), "retrochain.arcade.v1.MsgUpdateGameScoreResponse")
	proto.RegisterType((*MsgActivateCombo)(nil), "retrochain.arcade.v1.MsgActivateCombo")
	proto.RegisterType((*MsgActivateComboResponse)(nil), "retrochain.arcade.v1.MsgActivateComboResponse")
	proto.RegisterType((*MsgUsePowerUp)(nil), "retrochain.arcade.v1.MsgUsePowerUp")
	proto.RegisterType((*MsgUsePowerUpResponse)(nil), "retrochain.arcade.v1.MsgUsePowerUpResponse")
	proto.RegisterType((*MsgContinueGame)(nil), "retrochain.arcade.v1.MsgContinueGame")
	proto.RegisterType((*MsgContinueGameResponse)(nil), "retrochain.arcade.v1.MsgContinueGameResponse")
	proto.RegisterType((*MsgClaimAchievement)(nil), "retrochain.arcade.v1.MsgClaimAchievement")
	proto.RegisterType((*MsgClaimAchievementResponse)(nil), "retrochain.arcade.v1.MsgClaimAchievementResponse")
	proto.RegisterType((*MsgCreateTournament)(nil), "retrochain.arcade.v1.MsgCreateTournament")
	proto.RegisterType((*MsgCreateTournamentResponse)(nil), "retrochain.arcade.v1.MsgCreateTournamentResponse")
	proto.RegisterType((*MsgJoinTournament)(nil), "retrochain.arcade.v1.MsgJoinTournament")
	proto.RegisterType((*MsgJoinTournamentResponse)(nil), "retrochain.arcade.v1.MsgJoinTournamentResponse")
	proto.RegisterType((*MsgSubmitTournamentScore)(nil), "retrochain.arcade.v1.MsgSubmitTournamentScore")
	proto.RegisterType((*MsgSubmitTournamentScoreResponse)(nil), "retrochain.arcade.v1.MsgSubmitTournamentScoreResponse")
	proto.RegisterType((*MsgSetHighScoreInitials)(nil), "retrochain.arcade.v1.MsgSetHighScoreInitials")
	proto.RegisterType((*MsgSetHighScoreInitialsResponse)(nil), "retrochain.arcade.v1.MsgSetHighScoreInitialsResponse")
}

func init() { proto.RegisterFile("retrochain/arcade/v1/tx.proto", fileDescriptor_d2b4261a8f20d0a7) }

var fileDescriptor_d2b4261a8f20d0a7 = []byte{
	// 1612 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcf, 0x6f, 0x14, 0x47,
	0x16, 0x76, 0x9b, 0xb1, 0xf1, 0xbc, 0x19, 0x1b, 0xd3, 0x18, 0x18, 0x0f, 0x30, 0x36, 0xcd, 0x7a,
	0xd7, 0x98, 0xc5, 0xb3, 0x18, 0x2d, 0x07, 0x56, 0xab, 0x95, 0xed, 0x65, 0xc1, 0xab, 0x38, 0x41,
	0xed, 0x38, 0x87, 0x44, 0x4a, 0xa7, 0xdc, 0x5d, 0x6e, 0x17, 0x4c, 0x77, 0x4f, 0xba, 0x6a, 0x06,
	0x1c, 0x45, 0x4a, 0x94, 0x44, 0x39, 0x44, 0x91, 0x82, 0x72, 0xc9, 0x31, 0xd7, 0x28, 0x27, 0x2b,
	0xca, 0x29, 0xc7, 0x9c, 0x38, 0x45, 0x28, 0xa7, 0x9c, 0x22, 0x04, 0x07, 0xff, 0x1b, 0x51, 0xfd,
	0xe8, 0x9f, 0xee, 0x19, 0x0f, 0x26, 0x5c, 0xac, 0xa9, 0xaf, 0xbe, 0xaa, 0xf7, 0xbe, 0x57, 0xf5,
	0xea, 0xbd, 0x36, 0x5c, 0x08, 0x31, 0x0b, 0x03, 0x7b, 0x07, 0x11, 0xbf, 0x89, 0x42, 0x1b, 0x39,
	0xb8, 0xd9, 0xbd, 0xd6, 0x64, 0x0f, 0x17, 0xdb, 0x61, 0xc0, 0x02, 0x7d, 0x2a, 0x99, 0x5e, 0x94,
	0xd3, 0x8b, 0xdd, 0x6b, 0xf5, 0x93, 0xc8, 0x23, 0x7e, 0xd0, 0x14, 0x7f, 0x25, 0xb1, 0x7e, 0xd6,
	0x0e, 0xa8, 0x17, 0xd0, 0xa6, 0x47, 0x5d, 0xbe, 0x81, 0x47, 0x5d, 0x35, 0x31, 0x2d, 0x27, 0x2c,
	0x31, 0x6a, 0xca, 0x81, 0x9a, 0x9a, 0x72, 0x03, 0x37, 0x90, 0x38, 0xff, 0xa5, 0xd0, 0x8b, 0x85,
	0x1e, 0xb5, 0x51, 0x88, 0xbc, 0x68, 0xa1, 0x51, 0x48, 0x71, 0xb1, 0x8f, 0x29, 0x51, 0x1c, 0xe3,
	0x67, 0x0d, 0x4e, 0xac, 0x53, 0x77, 0xb3, 0xed, 0x20, 0x86, 0xef, 0x8a, 0xd5, 0xfa, 0x0d, 0x28,
	0xa3, 0x0e, 0xdb, 0x09, 0x42, 0xc2, 0x76, 0x6b, 0xda, 0xac, 0x36, 0x5f, 0x5e, 0xa9, 0xfd, 0xfa,
	0xe3, 0xd5, 0x29, 0xe5, 0xd5, 0xb2, 0xe3, 0x84, 0x98, 0xd2, 0x0d, 0x16, 0x12, 0xdf, 0x35, 0x13,
	0xaa, 0xfe, 0x1f, 0x18, 0x95, 0xf6, 0x6b, 0xc3, 0xb3, 0xda, 0x7c, 0x65, 0xe9, 0xfc, 0x62, 0x51,
	0x58, 0x16, 0xa5, 0x95, 0x95, 0xf2, 0xe3, 0xdf, 0x67, 0x86, 0xbe, 0xdb, 0xdf, 0x5b, 0xd0, 0x4c,
	0xb5, 0xec, 0xe6, 0x8d, 0x4f, 0xf6, 0xf7, 0x16, 0x92, 0x0d, 0xbf, 0xd8, 0xdf, 0x5b, 0xb8, 0x94,
	0xd2, 0xf0, 0x30, 0x52, 0x91, 0x73, 0xd8, 0x98, 0x86, 0xb3, 0x39, 0xc8, 0xc4, 0xb4, 0x1d, 0xf8,
	0x14, 0x1b, 0x9f, 0x69, 0x30, 0xbe, 0x4e, 0xdd, 0x35, 0x9f, 0xe2, 0x90, 0xad, 0x06, 0xc4, 0xd7,
	0x97, 0xe0, 0xb8, 0x1d, 0x62, 0xc4, 0x82, 0xf0, 0x50, 0x6d, 0x11, 0x51, 0xaf, 0x89, 0x35, 0x0e,
	0x61, 0x52, 0x5a, 0xc9, 0x8c, 0x86, 0xfa, 0x59, 0x38, 0xee, 0x22, 0x0f, 0x5b, 0xc4, 0xa9, 0x1d,
	0xe3, 0xbb, 0x99, 0xa3, 0x7c, 0xb8, 0xe6, 0xdc, 0xac, 0x72, 0x2d, 0xd1, 0x06, 0x86, 0x05, 0xa7,
	0x33, 0x5e, 0x44, 0xfe, 0xe9, 0x97, 0x60, 0x9c, 0x05, 0x0c, 0xb5, 0xac, 0x68, 0x7f, 0x4d, 0xec,
	0x5f, 0x15, 0xe0, 0xaa, 0x32, 0x72, 0x11, 0xaa, 0x2c, 0xb8, 0x8f, 0x7d, 0x6a, 0xd1, 0x36, 0xf6,
	0x99, 0xf0, 0xa1, 0x6c, 0x56, 0x24, 0xb6, 0xc1, 0x21, 0xe3, 0x4b, 0x79, 0x8e, 0x1b, 0x0c, 0x85,
	0x6c, 0x03, 0x53, 0x4a, 0x82, 0xa3, 0x29, 0x4d, 0xe9, 0x19, 0x4e, 0xeb, 0xd1, 0x1b, 0x00, 0x0e,
	0xd9, 0xde, 0x26, 0x76, 0xa7, 0xc5, 0x76, 0x85, 0xd6, 0x92, 0x99, 0x42, 0x72, 0x7a, 0x3f, 0xd7,
	0xc4, 0x91, 0xa4, 0xdd, 0x89, 0x25, 0x5f, 0x00, 0xa0, 0x12, 0xe2, 0x56, 0xa4, 0xde, 0xb2, 0x42,
	0xd6, 0x1c, 0x7d, 0x0e, 0x26, 0x28, 0x5f, 0x46, 0x7c, 0xd7, 0x6a, 0x91, 0x2e, 0x8e, 0x42, 0x3e,
	0x1e, 0xa1, 0xaf, 0x71, 0x30, 0x4b, 0xc3, 0x5d, 0xdc, 0x52, 0x3e, 0x25, 0x34, 0x0e, 0x1a, 0x3f,
	0x69, 0x30, 0xc1, 0x1d, 0xe9, 0x6c, 0x79, 0x84, 0x6d, 0xd8, 0x41, 0x88, 0x8f, 0x14, 0x96, 0xac,
	0xcf, 0xc3, 0x79, 0x9f, 0xa7, 0x60, 0x84, 0xf2, 0xbd, 0x95, 0x0f, 0x72, 0xc0, 0x51, 0xe9, 0x59,
	0x49, 0xa2, 0x62, 0xa0, 0x9f, 0x83, 0xb2, 0x88, 0x70, 0xd0, 0xc5, 0x61, 0x6d, 0x64, 0x56, 0x9b,
	0x1f, 0x33, 0xc7, 0x38, 0xf0, 0x46, 0x17, 0x87, 0xb9, 0x28, 0x7e, 0xaf, 0xc1, 0x99, 0xac, 0xf3,
	0x71, 0x10, 0x0d, 0x18, 0x27, 0xd4, 0xda, 0x21, 0xee, 0x8e, 0x25, 0x2d, 0x6b, 0x62, 0xa7, 0x0a,
	0xa1, 0x77, 0x88, 0xbb, 0x23, 0x85, 0xea, 0x50, 0x0a, 0x91, 0x7f, 0x5f, 0xb9, 0x2b, 0x7e, 0xcb,
	0xfb, 0x26, 0xae, 0x12, 0x46, 0xa1, 0x8f, 0x1d, 0xe5, 0xb1, 0xba, 0x5f, 0xb7, 0x04, 0xa6, 0x5f,
	0x87, 0xd3, 0xc8, 0xde, 0x21, 0xb8, 0x8b, 0x3d, 0xec, 0x33, 0x6a, 0x75, 0xfc, 0x56, 0x60, 0xdf,
	0xc7, 0x4e, 0xad, 0x34, 0x7b, 0x6c, 0xbe, 0x6c, 0x4e, 0xa5, 0x27, 0x37, 0xd5, 0x9c, 0xf1, 0x83,
	0xcc, 0xb4, 0x5b, 0xbe, 0xf3, 0x32, 0xf7, 0xef, 0x90, 0x40, 0xcf, 0x40, 0x65, 0x9b, 0xf8, 0xa8,
	0x65, 0xa5, 0xc3, 0x0d, 0x02, 0x92, 0x9a, 0x63, 0x42, 0x3a, 0xf2, 0x92, 0x20, 0x2e, 0x44, 0x2e,
	0xc2, 0x6f, 0x89, 0xbc, 0x4c, 0x7c, 0x4e, 0xe7, 0x65, 0xe4, 0x07, 0xf6, 0x1d, 0xec, 0xa8, 0xf8,
	0x56, 0x15, 0x78, 0x8b, 0x63, 0xfc, 0x59, 0xa0, 0x1d, 0xcf, 0x43, 0xe1, 0xae, 0x4a, 0x96, 0x68,
	0x68, 0x7c, 0x25, 0xd3, 0xd1, 0xc4, 0x2e, 0xa1, 0x0c, 0x87, 0xb7, 0x91, 0x77, 0xb4, 0x7b, 0x77,
	0x13, 0x4a, 0xfc, 0x6e, 0xa8, 0x07, 0x75, 0xb6, 0xf8, 0x41, 0x5d, 0x16, 0xbf, 0xb8, 0x8d, 0x95,
	0x12, 0x7f, 0x54, 0x4d, 0xb1, 0x26, 0xa7, 0x74, 0x49, 0x24, 0x64, 0xda, 0xa1, 0x58, 0x6b, 0x2a,
	0xe7, 0xb5, 0x74, 0xce, 0x1b, 0x4f, 0x35, 0xd0, 0xe3, 0x87, 0x95, 0x2f, 0x79, 0x65, 0x09, 0x34,
	0x03, 0x15, 0x71, 0xa2, 0x96, 0x83, 0x5b, 0x0c, 0x45, 0xe7, 0x2a, 0xa0, 0xff, 0x72, 0x84, 0x9f,
	0x87, 0xdd, 0x09, 0x43, 0xec, 0xb3, 0xcc, 0xc9, 0x56, 0x15, 0x28, 0xce, 0x36, 0x43, 0x12, 0x2f,
	0xc7, 0x48, 0x96, 0xc4, 0xb1, 0x5c, 0x58, 0xfe, 0x0d, 0xf5, 0x83, 0x0a, 0xe3, 0xc8, 0xcc, 0x40,
	0x45, 0xbe, 0xce, 0x49, 0x8e, 0x95, 0x4c, 0x10, 0x90, 0x20, 0x1a, 0x5f, 0x6b, 0x30, 0xb9, 0x4e,
	0xdd, 0x65, 0x9b, 0x91, 0x2e, 0x62, 0x78, 0x35, 0xf0, 0xb6, 0x82, 0x57, 0x11, 0x9f, 0x0b, 0x00,
	0x36, 0xdf, 0xdb, 0xda, 0xe1, 0x35, 0x42, 0x86, 0xa7, 0x2c, 0x90, 0x3b, 0x84, 0xe5, 0x35, 0xbd,
	0x03, 0xb5, 0xbc, 0x4f, 0xb1, 0xa2, 0x06, 0x80, 0xd7, 0x69, 0x31, 0xd2, 0x6e, 0x11, 0x1c, 0x46,
	0x82, 0x12, 0x84, 0x2b, 0xde, 0x0a, 0xfc, 0x0e, 0x55, 0x8a, 0xa5, 0x23, 0x20, 0x20, 0xa9, 0xf8,
	0x91, 0x4c, 0xf3, 0x4d, 0x8a, 0xef, 0x06, 0x0f, 0x70, 0xb8, 0xd9, 0x7e, 0x15, 0x72, 0x1b, 0x50,
	0x69, 0xf3, 0xdd, 0xad, 0x4e, 0x3b, 0xa9, 0xac, 0xe5, 0xb6, 0x34, 0x78, 0xa0, 0xb8, 0xae, 0x8b,
	0x24, 0x4e, 0x3c, 0x8a, 0xc5, 0x9e, 0x87, 0x32, 0x52, 0x51, 0x88, 0x12, 0x38, 0x01, 0xf4, 0x33,
	0x30, 0x8a, 0xb7, 0xb7, 0xb1, 0x1d, 0xd5, 0x53, 0x35, 0x32, 0x42, 0x91, 0xba, 0xab, 0x81, 0xcf,
	0x88, 0xdf, 0xc1, 0x47, 0x4e, 0xdd, 0xfe, 0x12, 0x73, 0x12, 0x3e, 0x95, 0xf5, 0x32, 0x6d, 0x34,
	0x56, 0xd1, 0x84, 0x53, 0xb6, 0xc2, 0xa9, 0x15, 0x62, 0x0f, 0x11, 0x9f, 0xf8, 0xae, 0x3a, 0x3b,
	0x3d, 0x9e, 0x32, 0xa3, 0x19, 0x9e, 0x06, 0xe2, 0xfa, 0x5b, 0x6e, 0x88, 0x7c, 0x2e, 0x5d, 0x1a,
	0xaf, 0x0a, 0xf0, 0xb6, 0xc4, 0x78, 0x71, 0xb0, 0x03, 0xca, 0x54, 0x6c, 0xc5, 0x6f, 0xe3, 0x1b,
	0x0d, 0x4e, 0x71, 0x2f, 0x5a, 0x88, 0x78, 0xcb, 0xc9, 0x1b, 0x7f, 0x24, 0xf9, 0x73, 0x30, 0x91,
	0x2a, 0x13, 0x49, 0x3f, 0x31, 0x9e, 0x42, 0xd7, 0x9c, 0x41, 0xfb, 0xa7, 0x00, 0xce, 0x15, 0x38,
	0x16, 0x87, 0x68, 0x0e, 0x26, 0x54, 0x55, 0x43, 0x0f, 0x50, 0x18, 0x3d, 0xd7, 0x25, 0x53, 0xd5,
	0xba, 0x65, 0x09, 0xea, 0x97, 0x61, 0x32, 0xed, 0x93, 0x1f, 0xbd, 0xac, 0x65, 0xf3, 0x44, 0x0a,
	0x7f, 0x1d, 0x79, 0xd8, 0xf8, 0x56, 0x85, 0x82, 0xdb, 0xc7, 0x6f, 0x06, 0x9d, 0x90, 0x93, 0x8f,
	0x18, 0x8a, 0xff, 0x01, 0xb0, 0x78, 0x87, 0xfe, 0x4f, 0x79, 0x62, 0x49, 0x3d, 0xe5, 0xa9, 0x95,
	0xb9, 0x90, 0xac, 0xc8, 0x90, 0xe4, 0x1c, 0xcc, 0x36, 0x96, 0x11, 0x9a, 0x3c, 0xed, 0xd5, 0x04,
	0x5c, 0x73, 0x8c, 0x0f, 0xe0, 0xe4, 0x3a, 0x75, 0xff, 0x1f, 0x10, 0xff, 0x25, 0x25, 0x1e, 0xb0,
	0x36, 0x7c, 0xd0, 0x5a, 0xce, 0xff, 0xf7, 0x60, 0xfa, 0x80, 0xed, 0xd8, 0xfb, 0x33, 0x30, 0x7a,
	0x2f, 0x20, 0x7e, 0x9c, 0xb6, 0x6a, 0xa4, 0x5f, 0x81, 0x93, 0x6d, 0xde, 0xde, 0xd9, 0xa4, 0x8d,
	0x7c, 0x66, 0xd9, 0x41, 0x47, 0x45, 0xb4, 0x64, 0x4e, 0xa6, 0x26, 0x56, 0x39, 0xce, 0xaf, 0x73,
	0x2d, 0x6e, 0x9f, 0x12, 0x23, 0x47, 0x2f, 0x62, 0x83, 0xa8, 0x2c, 0xee, 0x05, 0x73, 0xda, 0x6d,
	0x98, 0xed, 0xe5, 0x58, 0x1c, 0x82, 0x8b, 0x10, 0xd5, 0x2d, 0x4b, 0x74, 0x71, 0xf2, 0x46, 0x57,
	0x14, 0x66, 0xf2, 0x66, 0xee, 0x3c, 0x94, 0xdf, 0xef, 0xa0, 0x16, 0xd9, 0x26, 0x2a, 0xc9, 0xc7,
	0xcc, 0x04, 0xe0, 0x2f, 0xb5, 0xe8, 0xc1, 0x31, 0x8b, 0x5b, 0xc2, 0x35, 0x9f, 0x30, 0x82, 0x5a,
	0xf4, 0xcf, 0xfd, 0x34, 0xa8, 0xc3, 0x18, 0x51, 0x1b, 0xab, 0x24, 0x8e, 0xc7, 0x39, 0xdd, 0xff,
	0x82, 0x99, 0x1e, 0x1e, 0xc5, 0xb2, 0x6b, 0x70, 0xbc, 0x23, 0xaa, 0x71, 0x74, 0xf4, 0xd1, 0x70,
	0xe9, 0x97, 0x2a, 0x1c, 0x5b, 0xa7, 0xae, 0xee, 0x40, 0x35, 0xf3, 0xb9, 0x3a, 0x57, 0x9c, 0x4a,
	0xb9, 0x2f, 0xc2, 0xfa, 0xd5, 0x81, 0x68, 0xb1, 0x1f, 0xef, 0x02, 0xa4, 0x3e, 0x1a, 0x2f, 0xf5,
	0x5c, 0x9c, 0x90, 0xea, 0x57, 0x06, 0x20, 0xc5, 0xfb, 0x3b, 0x50, 0xcd, 0x7c, 0xac, 0xf5, 0x56,
	0x91, 0xa6, 0xf5, 0x51, 0x51, 0xf8, 0xad, 0x85, 0xa0, 0x92, 0xfe, 0xf4, 0xf9, 0x4b, 0xef, 0xd5,
	0x09, 0xab, 0xfe, 0xf7, 0x41, 0x58, 0xe9, 0x40, 0xa5, 0x7a, 0xfe, 0xde, 0x81, 0x4a, 0x48, 0x7d,
	0x02, 0x55, 0xd0, 0x89, 0x3b, 0x50, 0xcd, 0xb4, 0xd1, 0xbd, 0x03, 0x95, 0xa6, 0xf5, 0x09, 0x54,
	0x61, 0x0f, 0xec, 0xc1, 0x89, 0x7c, 0x9b, 0x3b, 0x7f, 0xc8, 0x85, 0x89, 0x99, 0xf5, 0x7f, 0x0c,
	0xca, 0x8c, 0xcd, 0xb9, 0x30, 0x9e, 0xed, 0x19, 0xff, 0xda, 0x73, 0x8b, 0x0c, 0xaf, 0xbe, 0x38,
	0x18, 0x2f, 0x7d, 0x3a, 0xa9, 0x56, 0xad, 0xf7, 0xe9, 0x24, 0xa4, 0x3e, 0xa7, 0x53, 0xd0, 0x62,
	0x39, 0x50, 0xcd, 0x74, 0x4a, 0xbd, 0x4f, 0x27, 0x4d, 0xeb, 0x73, 0x3a, 0x85, 0x2d, 0x50, 0x1b,
	0x26, 0x0f, 0x34, 0x25, 0x97, 0x7b, 0x6f, 0x91, 0xa3, 0xd6, 0xaf, 0x0d, 0x4c, 0xcd, 0x58, 0xcc,
	0xd7, 0xfe, 0x3e, 0x16, 0x73, 0xd4, 0x7e, 0x16, 0x7b, 0x15, 0xec, 0x7b, 0x30, 0x91, 0x2b, 0xc4,
	0x7f, 0xeb, 0xb9, 0x49, 0x96, 0x58, 0x6f, 0x0e, 0x48, 0x8c, 0x6d, 0x7d, 0x04, 0xa7, 0x8b, 0xab,
	0xe2, 0xe2, 0x21, 0xa9, 0x9f, 0xe3, 0xd7, 0x6f, 0xbc, 0x18, 0x3f, 0x76, 0xe0, 0x43, 0x98, 0x2a,
	0xac, 0x4b, 0x7d, 0x9e, 0xb7, 0x02, 0x7a, 0xfd, 0x9f, 0x2f, 0x44, 0x8f, 0xac, 0xd7, 0x47, 0x3e,
	0xde, 0xdf, 0x5b, 0xd0, 0x56, 0xae, 0x3f, 0x7e, 0xd6, 0xd0, 0x9e, 0x3c, 0x6b, 0x68, 0x4f, 0x9f,
	0x35, 0xb4, 0x47, 0xcf, 0x1b, 0x43, 0x4f, 0x9e, 0x37, 0x86, 0x7e, 0x7b, 0xde, 0x18, 0x7a, 0x7b,
	0xba, 0xe8, 0xbf, 0x8e, 0x6c, 0xb7, 0x8d, 0xe9, 0xd6, 0xa8, 0xf8, 0xbf, 0xe9, 0xf5, 0x3f, 0x02,
	0x00, 0x00, 0xff, 0xff, 0x58, 0x23, 0x2d, 0xb7, 0x12, 0x16, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	// InsertCoin defines the InsertCoin RPC - buy credits to play
	InsertCoin(ctx context.Context, in *MsgInsertCoin, opts ...grpc.CallOption) (*MsgInsertCoinResponse, error)
	// StartSession defines the StartSession RPC - start a new game
	StartSession(ctx context.Context, in *MsgStartSession, opts ...grpc.CallOption) (*MsgStartSessionResponse, error)
	// SubmitScore defines the SubmitScore RPC - submit game score
	SubmitScore(ctx context.Context, in *MsgSubmitScore, opts ...grpc.CallOption) (*MsgSubmitScoreResponse, error)
	// EndSession defines the EndSession RPC - end a game session
	EndSession(ctx context.Context, in *MsgEndSession, opts ...grpc.CallOption) (*MsgEndSessionResponse, error)
	// RegisterGame defines the RegisterGame RPC - add new arcade game
	RegisterGame(ctx context.Context, in *MsgRegisterGame, opts ...grpc.CallOption) (*MsgRegisterGameResponse, error)
	// UpdateGameScore defines the UpdateGameScore RPC - update score during play
	UpdateGameScore(ctx context.Context, in *MsgUpdateGameScore, opts ...grpc.CallOption) (*MsgUpdateGameScoreResponse, error)
	// ActivateCombo defines the ActivateCombo RPC - trigger combo multiplier
	ActivateCombo(ctx context.Context, in *MsgActivateCombo, opts ...grpc.CallOption) (*MsgActivateComboResponse, error)
	// UsePowerUp defines the UsePowerUp RPC - use a power-up during game
	UsePowerUp(ctx context.Context, in *MsgUsePowerUp, opts ...grpc.CallOption) (*MsgUsePowerUpResponse, error)
	// ContinueGame defines the ContinueGame RPC - continue after game over
	ContinueGame(ctx context.Context, in *MsgContinueGame, opts ...grpc.CallOption) (*MsgContinueGameResponse, error)
	// ClaimAchievement defines the ClaimAchievement RPC - claim achievement reward
	ClaimAchievement(ctx context.Context, in *MsgClaimAchievement, opts ...grpc.CallOption) (*MsgClaimAchievementResponse, error)
	// CreateTournament defines the CreateTournament RPC - create new tournament
	CreateTournament(ctx context.Context, in *MsgCreateTournament, opts ...grpc.CallOption) (*MsgCreateTournamentResponse, error)
	// JoinTournament defines the JoinTournament RPC - join a tournament
	JoinTournament(ctx context.Context, in *MsgJoinTournament, opts ...grpc.CallOption) (*MsgJoinTournamentResponse, error)
	// SubmitTournamentScore defines the SubmitTournamentScore RPC
	SubmitTournamentScore(ctx context.Context, in *MsgSubmitTournamentScore, opts ...grpc.CallOption) (*MsgSubmitTournamentScoreResponse, error)
	// SetHighScoreInitials defines the SetHighScoreInitials RPC
	SetHighScoreInitials(ctx context.Context, in *MsgSetHighScoreInitials, opts ...grpc.CallOption) (*MsgSetHighScoreInitialsResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/retrochain.arcade.v1.Msg/UpdateParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) InsertCoin(ctx context.Context, in *MsgInsertCoin, opts ...grpc.CallOption) (*MsgInsertCoinResponse, error) {
	out := new(MsgInsertCoinResponse)
	err := c.cc.Invoke(ctx, "/retrochain.arcade.v1.Msg/InsertCoin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) StartSession(ctx context.Context, in *MsgStartSession, opts ...grpc.CallOption) (*MsgStartSessionResponse, error) {
	out := new(MsgStartSessionResponse)
	err := c.cc.Invoke(ctx, "/retrochain.arcade.v1.Msg/StartSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitScore(ctx context.Context, in *MsgSubmitScore, opts ...grpc.CallOption) (*MsgSubmitScoreResponse, error) {
	out := new(MsgSubmitScoreResponse)
	err := c.cc.Invoke(ctx, "/retrochain.arcade.v1.Msg/SubmitScore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) EndSession(ctx context.Context, in *MsgEndSession, opts ...grpc.CallOption) (*MsgEndSessionResponse, error) {
	out := new(MsgEndSessionResponse)
	err := c.cc.Invoke(ctx, "/retrochain.arcade.v1.Msg/EndSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RegisterGame(ctx context.Context, in *MsgRegisterGame, opts ...grpc.CallOption) (*MsgRegisterGameResponse, error) {
	out := new(MsgRegisterGameResponse)
	err := c.cc.Invoke(ctx, "/retrochain.arcade.v1.Msg/RegisterGame", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateGameScore(ctx context.Context, in *MsgUpdateGameScore, opts ...grpc.CallOption) (*MsgUpdateGameScoreResponse, error) {
	out := new(MsgUpdateGameScoreResponse)
	err := c.cc.Invoke(ctx, "/retrochain.arcade.v1.Msg/UpdateGameScore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ActivateCombo(ctx context.Context, in *MsgActivateCombo, opts ...grpc.CallOption) (*MsgActivateComboResponse, error) {
	out := new(MsgActivateComboResponse)
	err := c.cc.Invoke(ctx, "/retrochain.arcade.v1.Msg/ActivateCombo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UsePowerUp(ctx context.Context, in *MsgUsePowerUp, opts ...grpc.CallOption) (*MsgUsePowerUpResponse, error) {
	out := new(MsgUsePowerUpResponse)
	err := c.cc.Invoke(ctx, "/retrochain.arcade.v1.Msg/UsePowerUp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ContinueGame(ctx context.Context, in *MsgContinueGame, opts ...grpc.CallOption) (*MsgContinueGameResponse, error) {
	out := new(MsgContinueGameResponse)
	err := c.cc.Invoke(ctx, "/retrochain.arcade.v1.Msg/ContinueGame", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ClaimAchievement(ctx context.Context, in *MsgClaimAchievement, opts ...grpc.CallOption) (*MsgClaimAchievementResponse, error) {
	out := new(MsgClaimAchievementResponse)
	err := c.cc.Invoke(ctx, "/retrochain.arcade.v1.Msg/ClaimAchievement", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateTournament(ctx context.Context, in *MsgCreateTournament, opts ...grpc.CallOption) (*MsgCreateTournamentResponse, error) {
	out := new(MsgCreateTournamentResponse)
	err := c.cc.Invoke(ctx, "/retrochain.arcade.v1.Msg/CreateTournament", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) JoinTournament(ctx context.Context, in *MsgJoinTournament, opts ...grpc.CallOption) (*MsgJoinTournamentResponse, error) {
	out := new(MsgJoinTournamentResponse)
	err := c.cc.Invoke(ctx, "/retrochain.arcade.v1.Msg/JoinTournament", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitTournamentScore(ctx context.Context, in *MsgSubmitTournamentScore, opts ...grpc.CallOption) (*MsgSubmitTournamentScoreResponse, error) {
	out := new(MsgSubmitTournamentScoreResponse)
	err := c.cc.Invoke(ctx, "/retrochain.arcade.v1.Msg/SubmitTournamentScore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SetHighScoreInitials(ctx context.Context, in *MsgSetHighScoreInitials, opts ...grpc.CallOption) (*MsgSetHighScoreInitialsResponse, error) {
	out := new(MsgSetHighScoreInitialsResponse)
	err := c.cc.Invoke(ctx, "/retrochain.arcade.v1.Msg/SetHighScoreInitials", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
	// InsertCoin defines the InsertCoin RPC - buy credits to play
	InsertCoin(context.Context, *MsgInsertCoin) (*MsgInsertCoinResponse, error)
	// StartSession defines the StartSession RPC - start a new game
	StartSession(context.Context, *MsgStartSession) (*MsgStartSessionResponse, error)
	// SubmitScore defines the SubmitScore RPC - submit game score
	SubmitScore(context.Context, *MsgSubmitScore) (*MsgSubmitScoreResponse, error)
	// EndSession defines the EndSession RPC - end a game session
	EndSession(context.Context, *MsgEndSession) (*MsgEndSessionResponse, error)
	// RegisterGame defines the RegisterGame RPC - add new arcade game
	RegisterGame(context.Context, *MsgRegisterGame) (*MsgRegisterGameResponse, error)
	// UpdateGameScore defines the UpdateGameScore RPC - update score during play
	UpdateGameScore(context.Context, *MsgUpdateGameScore) (*MsgUpdateGameScoreResponse, error)
	// ActivateCombo defines the ActivateCombo RPC - trigger combo multiplier
	ActivateCombo(context.Context, *MsgActivateCombo) (*MsgActivateComboResponse, error)
	// UsePowerUp defines the UsePowerUp RPC - use a power-up during game
	UsePowerUp(context.Context, *MsgUsePowerUp) (*MsgUsePowerUpResponse, error)
	// ContinueGame defines the ContinueGame RPC - continue after game over
	ContinueGame(context.Context, *MsgContinueGame) (*MsgContinueGameResponse, error)
	// ClaimAchievement defines the ClaimAchievement RPC - claim achievement reward
	ClaimAchievement(context.Context, *MsgClaimAchievement) (*MsgClaimAchievementResponse, error)
	// CreateTournament defines the CreateTournament RPC - create new tournament
	CreateTournament(context.Context, *MsgCreateTournament) (*MsgCreateTournamentResponse, error)
	// JoinTournament defines the JoinTournament RPC - join a tournament
	JoinTournament(context.Context, *MsgJoinTournament) (*MsgJoinTournamentResponse, error)
	// SubmitTournamentScore defines the SubmitTournamentScore RPC
	SubmitTournamentScore(context.Context, *MsgSubmitTournamentScore) (*MsgSubmitTournamentScoreResponse, error)
	// SetHighScoreInitials defines the SetHighScoreInitials RPC
	SetHighScoreInitials(context.Context, *MsgSetHighScoreInitials) (*MsgSetHighScoreInitialsResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}
func (*UnimplementedMsgServer) InsertCoin(ctx context.Context, req *MsgInsertCoin) (*MsgInsertCoinResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InsertCoin not implemented")
}
func (*UnimplementedMsgServer) StartSession(ctx context.Context, req *MsgStartSession) (*MsgStartSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartSession not implemented")
}
func (*UnimplementedMsgServer) SubmitScore(ctx context.Context, req *MsgSubmitScore) (*MsgSubmitScoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitScore not implemented")
}
func (*UnimplementedMsgServer) EndSession(ctx context.Context, req *MsgEndSession) (*MsgEndSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EndSession not implemented")
}
func (*UnimplementedMsgServer) RegisterGame(ctx context.Context, req *MsgRegisterGame) (*MsgRegisterGameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterGame not implemented")
}
func (*UnimplementedMsgServer) UpdateGameScore(ctx context.Context, req *MsgUpdateGameScore) (*MsgUpdateGameScoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGameScore not implemented")
}
func (*UnimplementedMsgServer) ActivateCombo(ctx context.Context, req *MsgActivateCombo) (*MsgActivateComboResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateCombo not implemented")
}
func (*UnimplementedMsgServer) UsePowerUp(ctx context.Context, req *MsgUsePowerUp) (*MsgUsePowerUpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UsePowerUp not implemented")
}
func (*UnimplementedMsgServer) ContinueGame(ctx context.Context, req *MsgContinueGame) (*MsgContinueGameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ContinueGame not implemented")
}
func (*UnimplementedMsgServer) ClaimAchievement(ctx context.Context, req *MsgClaimAchievement) (*MsgClaimAchievementResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimAchievement not implemented")
}
func (*UnimplementedMsgServer) CreateTournament(ctx context.Context, req *MsgCreateTournament) (*MsgCreateTournamentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTournament not implemented")
}
func (*UnimplementedMsgServer) JoinTournament(ctx context.Context, req *MsgJoinTournament) (*MsgJoinTournamentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinTournament not implemented")
}
func (*UnimplementedMsgServer) SubmitTournamentScore(ctx context.Context, req *MsgSubmitTournamentScore) (*MsgSubmitTournamentScoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitTournamentScore not implemented")
}
func (*UnimplementedMsgServer) SetHighScoreInitials(ctx context.Context, req *MsgSetHighScoreInitials) (*MsgSetHighScoreInitialsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetHighScoreInitials not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/retrochain.arcade.v1.Msg/UpdateParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_InsertCoin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgInsertCoin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).InsertCoin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/retrochain.arcade.v1.Msg/InsertCoin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).InsertCoin(ctx, req.(*MsgInsertCoin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_StartSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgStartSession)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).StartSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/retrochain.arcade.v1.Msg/StartSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).StartSession(ctx, req.(*MsgStartSession))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitScore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/retrochain.arcade.v1.Msg/SubmitScore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitScore(ctx, req.(*MsgSubmitScore))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_EndSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgEndSession)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).EndSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/retrochain.arcade.v1.Msg/EndSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).EndSession(ctx, req.(*MsgEndSession))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RegisterGame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterGame)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterGame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/retrochain.arcade.v1.Msg/RegisterGame",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterGame(ctx, req.(*MsgRegisterGame))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateGameScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateGameScore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateGameScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/retrochain.arcade.v1.Msg/UpdateGameScore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateGameScore(ctx, req.(*MsgUpdateGameScore))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ActivateCombo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgActivateCombo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ActivateCombo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/retrochain.arcade.v1.Msg/ActivateCombo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ActivateCombo(ctx, req.(*MsgActivateCombo))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UsePowerUp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUsePowerUp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UsePowerUp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/retrochain.arcade.v1.Msg/UsePowerUp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UsePowerUp(ctx, req.(*MsgUsePowerUp))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ContinueGame_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgContinueGame)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ContinueGame(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/retrochain.arcade.v1.Msg/ContinueGame",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ContinueGame(ctx, req.(*MsgContinueGame))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ClaimAchievement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgClaimAchievement)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ClaimAchievement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/retrochain.arcade.v1.Msg/ClaimAchievement",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ClaimAchievement(ctx, req.(*MsgClaimAchievement))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateTournament_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateTournament)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateTournament(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/retrochain.arcade.v1.Msg/CreateTournament",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateTournament(ctx, req.(*MsgCreateTournament))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_JoinTournament_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgJoinTournament)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).JoinTournament(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/retrochain.arcade.v1.Msg/JoinTournament",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).JoinTournament(ctx, req.(*MsgJoinTournament))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitTournamentScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitTournamentScore)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitTournamentScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/retrochain.arcade.v1.Msg/SubmitTournamentScore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitTournamentScore(ctx, req.(*MsgSubmitTournamentScore))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SetHighScoreInitials_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSetHighScoreInitials)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SetHighScoreInitials(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/retrochain.arcade.v1.Msg/SetHighScoreInitials",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SetHighScoreInitials(ctx, req.(*MsgSetHighScoreInitials))
	}
	return interceptor(ctx, in, info, handler)
}

var Msg_serviceDesc = _Msg_serviceDesc
var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "retrochain.arcade.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
		{
			MethodName: "InsertCoin",
			Handler:    _Msg_InsertCoin_Handler,
		},
		{
			MethodName: "StartSession",
			Handler:    _Msg_StartSession_Handler,
		},
		{
			MethodName: "SubmitScore",
			Handler:    _Msg_SubmitScore_Handler,
		},
		{
			MethodName: "EndSession",
			Handler:    _Msg_EndSession_Handler,
		},
		{
			MethodName: "RegisterGame",
			Handler:    _Msg_RegisterGame_Handler,
		},
		{
			MethodName: "UpdateGameScore",
			Handler:    _Msg_UpdateGameScore_Handler,
		},
		{
			MethodName: "ActivateCombo",
			Handler:    _Msg_ActivateCombo_Handler,
		},
		{
			MethodName: "UsePowerUp",
			Handler:    _Msg_UsePowerUp_Handler,
		},
		{
			MethodName: "ContinueGame",
			Handler:    _Msg_ContinueGame_Handler,
		},
		{
			MethodName: "ClaimAchievement",
			Handler:    _Msg_ClaimAchievement_Handler,
		},
		{
			MethodName: "CreateTournament",
			Handler:    _Msg_CreateTournament_Handler,
		},
		{
			MethodName: "JoinTournament",
			Handler:    _Msg_JoinTournament_Handler,
		},
		{
			MethodName: "SubmitTournamentScore",
			Handler:    _Msg_SubmitTournamentScore_Handler,
		},
		{
			MethodName: "SetHighScoreInitials",
			Handler:    _Msg_SetHighScoreInitials_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "retrochain/arcade/v1/tx.proto",
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgInsertCoin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInsertCoin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInsertCoin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GameId) > 0 {
		i -= len(m.GameId)
		copy(dAtA[i:], m.GameId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.GameId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Credits != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Credits))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgInsertCoinResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgInsertCoinResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgInsertCoinResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TokensSpent) > 0 {
		i -= len(m.TokensSpent)
		copy(dAtA[i:], m.TokensSpent)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TokensSpent)))
		i--
		dAtA[i] = 0x12
	}
	if m.TotalCredits != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TotalCredits))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgStartSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgStartSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgStartSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Difficulty != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Difficulty))
		i--
		dAtA[i] = 0x18
	}
	if len(m.GameId) > 0 {
		i -= len(m.GameId)
		copy(dAtA[i:], m.GameId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.GameId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgStartSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgStartSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgStartSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StartingLevel != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.StartingLevel))
		i--
		dAtA[i] = 0x18
	}
	if m.StartingLives != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.StartingLives))
		i--
		dAtA[i] = 0x10
	}
	if m.SessionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SessionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitScore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitScore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GameOver {
		i--
		if m.GameOver {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Level != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x20
	}
	if m.Score != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x18
	}
	if m.SessionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SessionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitScoreResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitScoreResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitScoreResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AchievementsUnlocked) > 0 {
		for iNdEx := len(m.AchievementsUnlocked) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AchievementsUnlocked[iNdEx])
			copy(dAtA[i:], m.AchievementsUnlocked[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.AchievementsUnlocked[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.TokensEarned != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TokensEarned))
		i--
		dAtA[i] = 0x18
	}
	if m.Rank != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x10
	}
	if m.IsHighScore {
		i--
		if m.IsHighScore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgEndSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEndSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEndSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FinalLevel != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.FinalLevel))
		i--
		dAtA[i] = 0x20
	}
	if m.FinalScore != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.FinalScore))
		i--
		dAtA[i] = 0x18
	}
	if m.SessionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SessionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgEndSessionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEndSessionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEndSessionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Summary) > 0 {
		i -= len(m.Summary)
		copy(dAtA[i:], m.Summary)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Summary)))
		i--
		dAtA[i] = 0x12
	}
	if m.SessionEnded {
		i--
		if m.SessionEnded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterGame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterGame) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterGame) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Game.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterGameResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterGameResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterGameResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GameId) > 0 {
		i -= len(m.GameId)
		copy(dAtA[i:], m.GameId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.GameId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateGameScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateGameScore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateGameScore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CurrentLives != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.CurrentLives))
		i--
		dAtA[i] = 0x28
	}
	if m.CurrentLevel != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.CurrentLevel))
		i--
		dAtA[i] = 0x20
	}
	if m.ScoreDelta != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ScoreDelta))
		i--
		dAtA[i] = 0x18
	}
	if m.SessionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SessionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateGameScoreResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateGameScoreResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateGameScoreResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalScore != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TotalScore))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgActivateCombo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgActivateCombo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgActivateCombo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ComboHits != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ComboHits))
		i--
		dAtA[i] = 0x18
	}
	if m.SessionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SessionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgActivateComboResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgActivateComboResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgActivateComboResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BonusScore != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.BonusScore))
		i--
		dAtA[i] = 0x10
	}
	if m.Multiplier != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Multiplier))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUsePowerUp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUsePowerUp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUsePowerUp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PowerUpId) > 0 {
		i -= len(m.PowerUpId)
		copy(dAtA[i:], m.PowerUpId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PowerUpId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.SessionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SessionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUsePowerUpResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUsePowerUpResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUsePowerUpResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Effect) > 0 {
		i -= len(m.Effect)
		copy(dAtA[i:], m.Effect)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Effect)))
		i--
		dAtA[i] = 0x12
	}
	if m.Activated {
		i--
		if m.Activated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgContinueGame) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgContinueGame) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgContinueGame) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SessionId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SessionId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgContinueGameResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgContinueGameResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgContinueGameResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cost) > 0 {
		i -= len(m.Cost)
		copy(dAtA[i:], m.Cost)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Cost)))
		i--
		dAtA[i] = 0x1a
	}
	if m.LivesGranted != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.LivesGranted))
		i--
		dAtA[i] = 0x10
	}
	if m.ContinuesRemaining != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ContinuesRemaining))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgClaimAchievement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimAchievement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimAchievement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GameId) > 0 {
		i -= len(m.GameId)
		copy(dAtA[i:], m.GameId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.GameId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AchievementId) > 0 {
		i -= len(m.AchievementId)
		copy(dAtA[i:], m.AchievementId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AchievementId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgClaimAchievementResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimAchievementResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimAchievementResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AchievementName) > 0 {
		i -= len(m.AchievementName)
		copy(dAtA[i:], m.AchievementName)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AchievementName)))
		i--
		dAtA[i] = 0x12
	}
	if m.TokensAwarded != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TokensAwarded))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateTournament) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateTournament) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateTournament) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Tournament.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateTournamentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateTournamentResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateTournamentResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TournamentId) > 0 {
		i -= len(m.TournamentId)
		copy(dAtA[i:], m.TournamentId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TournamentId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgJoinTournament) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgJoinTournament) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgJoinTournament) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TournamentId) > 0 {
		i -= len(m.TournamentId)
		copy(dAtA[i:], m.TournamentId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TournamentId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgJoinTournamentResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgJoinTournamentResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgJoinTournamentResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ParticipantCount != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ParticipantCount))
		i--
		dAtA[i] = 0x10
	}
	if m.Joined {
		i--
		if m.Joined {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitTournamentScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitTournamentScore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitTournamentScore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Score != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x18
	}
	if len(m.TournamentId) > 0 {
		i -= len(m.TournamentId)
		copy(dAtA[i:], m.TournamentId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TournamentId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitTournamentScoreResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitTournamentScoreResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitTournamentScoreResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Qualified {
		i--
		if m.Qualified {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.CurrentRank != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.CurrentRank))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetHighScoreInitials) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetHighScoreInitials) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetHighScoreInitials) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Initials) > 0 {
		i -= len(m.Initials)
		copy(dAtA[i:], m.Initials)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Initials)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.GameId) > 0 {
		i -= len(m.GameId)
		copy(dAtA[i:], m.GameId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.GameId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Creator) > 0 {
		i -= len(m.Creator)
		copy(dAtA[i:], m.Creator)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Creator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSetHighScoreInitialsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSetHighScoreInitialsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSetHighScoreInitialsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Updated {
		i--
		if m.Updated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgInsertCoin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Credits != 0 {
		n += 1 + sovTx(uint64(m.Credits))
	}
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgInsertCoinResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalCredits != 0 {
		n += 1 + sovTx(uint64(m.TotalCredits))
	}
	l = len(m.TokensSpent)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgStartSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Difficulty != 0 {
		n += 1 + sovTx(uint64(m.Difficulty))
	}
	return n
}

func (m *MsgStartSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionId != 0 {
		n += 1 + sovTx(uint64(m.SessionId))
	}
	if m.StartingLives != 0 {
		n += 1 + sovTx(uint64(m.StartingLives))
	}
	if m.StartingLevel != 0 {
		n += 1 + sovTx(uint64(m.StartingLevel))
	}
	return n
}

func (m *MsgSubmitScore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SessionId != 0 {
		n += 1 + sovTx(uint64(m.SessionId))
	}
	if m.Score != 0 {
		n += 1 + sovTx(uint64(m.Score))
	}
	if m.Level != 0 {
		n += 1 + sovTx(uint64(m.Level))
	}
	if m.GameOver {
		n += 2
	}
	return n
}

func (m *MsgSubmitScoreResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsHighScore {
		n += 2
	}
	if m.Rank != 0 {
		n += 1 + sovTx(uint64(m.Rank))
	}
	if m.TokensEarned != 0 {
		n += 1 + sovTx(uint64(m.TokensEarned))
	}
	if len(m.AchievementsUnlocked) > 0 {
		for _, s := range m.AchievementsUnlocked {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	return n
}

func (m *MsgEndSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SessionId != 0 {
		n += 1 + sovTx(uint64(m.SessionId))
	}
	if m.FinalScore != 0 {
		n += 1 + sovTx(uint64(m.FinalScore))
	}
	if m.FinalLevel != 0 {
		n += 1 + sovTx(uint64(m.FinalLevel))
	}
	return n
}

func (m *MsgEndSessionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionEnded {
		n += 2
	}
	l = len(m.Summary)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRegisterGame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Game.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgRegisterGameResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateGameScore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SessionId != 0 {
		n += 1 + sovTx(uint64(m.SessionId))
	}
	if m.ScoreDelta != 0 {
		n += 1 + sovTx(uint64(m.ScoreDelta))
	}
	if m.CurrentLevel != 0 {
		n += 1 + sovTx(uint64(m.CurrentLevel))
	}
	if m.CurrentLives != 0 {
		n += 1 + sovTx(uint64(m.CurrentLives))
	}
	return n
}

func (m *MsgUpdateGameScoreResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalScore != 0 {
		n += 1 + sovTx(uint64(m.TotalScore))
	}
	return n
}

func (m *MsgActivateCombo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SessionId != 0 {
		n += 1 + sovTx(uint64(m.SessionId))
	}
	if m.ComboHits != 0 {
		n += 1 + sovTx(uint64(m.ComboHits))
	}
	return n
}

func (m *MsgActivateComboResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Multiplier != 0 {
		n += 1 + sovTx(uint64(m.Multiplier))
	}
	if m.BonusScore != 0 {
		n += 1 + sovTx(uint64(m.BonusScore))
	}
	return n
}

func (m *MsgUsePowerUp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SessionId != 0 {
		n += 1 + sovTx(uint64(m.SessionId))
	}
	l = len(m.PowerUpId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUsePowerUpResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Activated {
		n += 2
	}
	l = len(m.Effect)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgContinueGame) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SessionId != 0 {
		n += 1 + sovTx(uint64(m.SessionId))
	}
	return n
}

func (m *MsgContinueGameResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContinuesRemaining != 0 {
		n += 1 + sovTx(uint64(m.ContinuesRemaining))
	}
	if m.LivesGranted != 0 {
		n += 1 + sovTx(uint64(m.LivesGranted))
	}
	l = len(m.Cost)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgClaimAchievement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.AchievementId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgClaimAchievementResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TokensAwarded != 0 {
		n += 1 + sovTx(uint64(m.TokensAwarded))
	}
	l = len(m.AchievementName)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCreateTournament) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Tournament.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgCreateTournamentResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TournamentId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgJoinTournament) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TournamentId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgJoinTournamentResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Joined {
		n += 2
	}
	if m.ParticipantCount != 0 {
		n += 1 + sovTx(uint64(m.ParticipantCount))
	}
	return n
}

func (m *MsgSubmitTournamentScore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TournamentId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovTx(uint64(m.Score))
	}
	return n
}

func (m *MsgSubmitTournamentScoreResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CurrentRank != 0 {
		n += 1 + sovTx(uint64(m.CurrentRank))
	}
	if m.Qualified {
		n += 2
	}
	return n
}

func (m *MsgSetHighScoreInitials) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Creator)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.GameId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Initials)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSetHighScoreInitialsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Updated {
		n += 2
	}
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInsertCoin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInsertCoin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInsertCoin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credits", wireType)
			}
			m.Credits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Credits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgInsertCoinResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgInsertCoinResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgInsertCoinResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCredits", wireType)
			}
			m.TotalCredits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCredits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokensSpent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TokensSpent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgStartSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgStartSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgStartSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Difficulty", wireType)
			}
			m.Difficulty = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Difficulty |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgStartSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgStartSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgStartSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartingLives", wireType)
			}
			m.StartingLives = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartingLives |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartingLevel", wireType)
			}
			m.StartingLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartingLevel |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameOver", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GameOver = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitScoreResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitScoreResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitScoreResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsHighScore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsHighScore = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokensEarned", wireType)
			}
			m.TokensEarned = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TokensEarned |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AchievementsUnlocked", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AchievementsUnlocked = append(m.AchievementsUnlocked, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEndSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEndSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEndSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalScore", wireType)
			}
			m.FinalScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinalScore |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalLevel", wireType)
			}
			m.FinalLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FinalLevel |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEndSessionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEndSessionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEndSessionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionEnded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SessionEnded = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Summary = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterGame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterGame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterGame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Game", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Game.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterGameResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterGameResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterGameResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateGameScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateGameScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateGameScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreDelta", wireType)
			}
			m.ScoreDelta = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScoreDelta |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentLevel", wireType)
			}
			m.CurrentLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentLevel |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentLives", wireType)
			}
			m.CurrentLives = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentLives |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateGameScoreResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateGameScoreResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateGameScoreResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalScore", wireType)
			}
			m.TotalScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalScore |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgActivateCombo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgActivateCombo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgActivateCombo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComboHits", wireType)
			}
			m.ComboHits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComboHits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgActivateComboResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgActivateComboResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgActivateComboResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiplier", wireType)
			}
			m.Multiplier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Multiplier |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BonusScore", wireType)
			}
			m.BonusScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BonusScore |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUsePowerUp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUsePowerUp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUsePowerUp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PowerUpId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PowerUpId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUsePowerUpResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUsePowerUpResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUsePowerUpResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Activated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Activated = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Effect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Effect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgContinueGame) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgContinueGame: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgContinueGame: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgContinueGameResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgContinueGameResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgContinueGameResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContinuesRemaining", wireType)
			}
			m.ContinuesRemaining = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContinuesRemaining |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LivesGranted", wireType)
			}
			m.LivesGranted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LivesGranted |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cost = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimAchievement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimAchievement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimAchievement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AchievementId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AchievementId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimAchievementResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimAchievementResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimAchievementResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokensAwarded", wireType)
			}
			m.TokensAwarded = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TokensAwarded |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AchievementName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AchievementName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateTournament) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateTournament: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateTournament: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tournament", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Tournament.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateTournamentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateTournamentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateTournamentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TournamentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TournamentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgJoinTournament) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgJoinTournament: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgJoinTournament: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TournamentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TournamentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgJoinTournamentResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgJoinTournamentResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgJoinTournamentResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Joined", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Joined = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParticipantCount", wireType)
			}
			m.ParticipantCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParticipantCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitTournamentScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitTournamentScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitTournamentScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TournamentId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TournamentId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitTournamentScoreResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitTournamentScoreResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitTournamentScoreResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentRank", wireType)
			}
			m.CurrentRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentRank |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qualified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Qualified = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetHighScoreInitials) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetHighScoreInitials: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetHighScoreInitials: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Creator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GameId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GameId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initials", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Initials = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSetHighScoreInitialsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSetHighScoreInitialsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSetHighScoreInitialsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Updated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Updated = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
